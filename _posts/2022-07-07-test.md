---
title: Criss-Cross multiplication algorithm
categories : [maths]
tags :  [algorithms]

---

# Introduction

Back in 2019, I stumbled upon [a Youtube video](https://www.youtube.com/watch?v=JhGzbN5YuPo) about a multiplication algorithm known as Criss-Cross multiplication algorithm. It comes from Vedic mathematics, a compendium of tricks for increasing the speed of mathematical calculations.
Unlike many other multiplication algorithms, the Criss-Cross algorithm is easy to use both mentally and on paper. And unsurprisingly it is much faster than the grade-school multiplication algorithm we all learnt.

In [less than 50 lines of code](https://github.com/creme332/big-integer-vedic-multiplication-algorithm/blob/main/Vedic%20Algorithm/VedicMultiplicationAlgorithm.cpp), I managed to multiply 1000-digit numbers (in string format) almost instantly. Moreover,  it is nearly twice as fast as the Karatsuba algorithm when multiplying numbers having less than 1000 digits.

In this blog I will try my best to give a clear and concise explanation of this unpopular algorithm and explain its implementation in C++. 

More details about Vedic math can be found [here](https://github.com/KVBharatBhushan/Vedic-Maths)

# Algorithm 
There is a sequence of pattern to follow when carrying out single digit products. The sequence itself depends on the number of digits in the numbers being multiplied. However, because of symmetry, remembering the patterns is a piece of cake.

## Steps 
1. For each pattern, compute the sum of all the required single digit product.
2. Add carry (if any) to this sum.
- The last digit of this result is concatenated to the left of our final answer.
- The remaining digits of our sum is our new carry.
- Repeat until all patterns have been exhausted.

## Pattern for 2-digit multiplication
![](https://github.com/creme332/big-integer-vedic-multiplication-algorithm/blob/main/Media%20Files/2x2+pattern.gif?raw=true)

> The dots represents digits and the lines represent the product of 2 digits.

Example :

> Multiply 29 and 12

![](https://github.com/creme332/big-integer-vedic-multiplication-algorithm/blob/main/Media%20Files/Example+1.gif?raw=true)

Step 1 : Multiply the digits in the right-most column to obtain 18. 

Step 1.1 : Write down only unit digit (8 in this case) and carry over the digit in the tens place (1 in this case).

Step 2 : There are two single-digit multiplication to carry out. Sum these products and add the carry from the previous step.

Repeat step 1.1

## Pattern for 3-digit multiplication
![](https://github.com/creme332/big-integer-vedic-multiplication-algorithm/blob/main/Media%20Files/3x3+pattern.gif?raw=true)

## Pattern for 4-digit multiplication 
![](https://github.com/creme332/big-integer-vedic-multiplication-algorithm/blob/main/Media%20Files/4x4+pattern.gif?raw=true)

## Things to note
- When the 2 numbers being multiplied have different lengths, simply prepend zeroes to the smaller number to make it the same length as the larger number. For example, the Criss-Cross multiplication of `512323` and `32` is same as the Criss-Cross multiplication of `512323` and `000032`.

- One of the advantages of the Criss-Cross algorithm is that the risk of integer overflow is small as it carries out the sum of single-digit products.


# Proof 
Even though I have not found a formal proof of the Criss-Cross algorithm, we can get some insights into why it works by comparing it side-by-side with the grade-school algorithm .  

Immediately we can notice some similarities :
![image](https://user-images.githubusercontent.com/65414576/155765960-2ec47174-1825-4c9d-8fa9-94a6a6086361.png)
# Code 

```cpp
    ll i = max, j = min;

    for (ll k = 0; k < lines; k++) {
        sum += (a[i] - '0') * (b[j] - '0');
        i--; j++;
    }
```
```min``` and ```max``` keep keep track of region within which the cross-multiplication will take place.

Example :

![](https://github.com/creme332/VedicMultiplicationAlgorithm/blob/a2b8ccf5951fdeb7a31f31aa4754585d8ac21d32/Media%20Files/3x3+min+max%5B2975%5D.gif)

![image](https://user-images.githubusercontent.com/65414576/155732674-d9b96441-29d1-42d6-99b4-a4a211b23a46.png)

`i` is the index used to iterate over `a` within region `[min, max]`.

`j` is the index used to iterate over `b` within region `[min, max]`.

## Case 1 : Both `a` and  `b` have `n` digits 
This is the simplest case. The total number of steps required is `2n-1`. (There are `n` patterns +  `n` reflected patterns. However, the `n`th pattern is counted twice so we minus 1.)

The number of 1-digit multiplication (or the number of lines drawn) at each step can be found as follows :
```cpp
        if (currentstep <= n) {lines = currentstep;}
        else {lines = n - (currentstep - n);} // or 2*n - currentstep
```

| Step number | Number of single digit product required |
| :---        |    :----:   |
| 1      | 1       |
| 2   | 2        | 
| 3   | 3        | 
| 4   | 4        | 
| ...   | ...        | 
| n   | n        | 
| n+1  | n-1        | 
| n+2   | n-2        | 
| n+3   | n-3        | 
| ...   | ...        | 
| 2n-1   | 1        | 

At each step, we will compute the sum of all the 1-digit multiplications required. From this sum we will obtain the carry for the next step and a digit of our answer. 
### Time complexity ###
The total number of single digit product is $n^2 + n - 1$  In comparison, the total number of single digit products for the Karatsuba algorithm is $n^{\log_2 3}.$

![image](https://user-images.githubusercontent.com/65414576/155828159-ae742681-dace-43b3-b0f9-542745d9b108.png)

As the number of digits in the integers being multiplied tends to infinity, the Karatsuba algorithm will perform better. However, for relatively small numbers (having less than 10,000 digits), the Karatsuba algorithm performs worse. 

### The pseudocode for Case 1 ###
```
Initialise the total number of steps
Initialise min and max to n-1

For each step
        Determine the number of 1-digit multiplication to be carried out
        Initialise sum to 0
        When the step number becomes > n (or when min becomes negative), set min to 0 and decrement max.
        
        For each 1-digit multiplication
                Increment sum
                Modify counters to move to next 1-digit multiplication
        
        Add previous carry to sum
        Update carry and answer
        Decrement min

If carry is non-zero, concatenate it to the left of answer.
Return answer

```

## Case 2 : `b` has fewer digits than `a` ## 
This case could be eliminated if we simply make both `a` and `b` the same length initially by adding leading zeroes to `b`. However, this approach is time-consuming because there will be unnecessary and will introduce leading zeroes in our final answer which must be removed.

To bypass this problem, we simply reduce the total number of steps and the number of single digit product at each step to eliminate cases where the 1-digit multiplication involves a leading zero.

The total number of steps is now found using :
```cpp
    const ll asize = static_cast<ll>(a.size());
    const ll bsize = static_cast<ll>(b.size());
    ll totalsteps = asize + bsize - 1;
```

For each step, we first find the expected number of 1-digit multiplication if `a` and `b` were the same length :
```cpp
        if (step <= asize) {
             lines = step;
        }
        else {
            lines= asize - (step- asize); // do not simplify as 2*asize might overflow
        }
```

When all the digits of `b` have been traversed, `min` becomes negative. Previously when `a` and `b` were the same length, we exited when `min` is negative. However, when they differ in length, we cannot exit. Now, each time `min` reaches the start of `b`, we decrement `max` and keep `min` at index 0 of `b`.
```cpp
        if (min < 0) {
            min = 0;
            max--;
        }
```
Then we reduce the number of 1-digit multiplication as follows :

```cpp
        if (min < 0) {
            min = 0;
            max--;
            if (step < asize) {
                lines -= step - bsize;
            }
            else {
                lines -= asize - bsize;
            }
        }
```
![](https://github.com/creme332/VedicMultiplicationAlgorithm/blob/693d7c3bdc8f90d6fb8dfaf60001f69f688ff516/Media%20Files/5x3+min+max.gif)

The rest of the code is same as that in Case 1.

## Time complexity ##
Time complexity : $\mathbb O(n^2)$

Worst case scenario : The 2 numbers have the same number of digits. 

# Testing 

- The number of test cases was atleast 100 to get statistically meaningful results. 

* For each test case
        
    *  A set of 2 random numbers with a pre-set number of digits is generated.

    * `vedic()` and `karatsuba()` take as parameter the **same** 2 random numbers.

    * The time taken by each function is calculated.

    * A counter `c` is incremented each time, the vedic algorithm takes less time.

    * The difference in times is also calculated.


| Number of digits |Number of test cases | Avg time for vedic() | Avg time of karatsuba() | % difference |
| :---             |:----:                 |:----:                |:----:                                   |:----:        |
| 100              | 1000                  | 6033                  | 343458                                  |        98.2  |
| 500              | 100                   |  2263                 | 131762                                |     98.2           |
| 1000             | 200                   |  172990               | 5794911                                  | 97.0            |

> The unit of time used is microseconds.

# Why use the Criss-Cross algorithm

- Much simpler to implement than the Karatsuba algorithm
- For most test cases, such as competitive programming, the Criss-Cross algorithm performs better.