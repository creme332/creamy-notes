---
title: Criss-Cross multiplication algorithm
categories : [maths]
tags :  [algorithms]
 
---
 
# Introduction
 
Back in 2019, I stumbled upon [a Youtube video](https://www.youtube.com/watch?v=JhGzbN5YuPo) about a multiplication algorithm known as Criss-Cross multiplication algorithm. It comes from Vedic mathematics, a compendium of tricks for increasing the speed of mathematical calculations.
Unlike many other multiplication algorithms, the Criss-Cross algorithm is easy to use both mentally and on paper. And unsurprisingly it is much faster than the grade-school multiplication algorithm we all learnt.
 
In less than [50 lines of code](https://github.com/creme332/big-integer-vedic-multiplication-algorithm/blob/main/Vedic%20Algorithm/VedicMultiplicationAlgorithm.cpp), the Vedic algorithm manages to multiply 1000-digit numbers (in string format) almost instantly. Moreover, when multiplying numbers having less than 1000 digits, it is nearly twice as fast as the [Karatsuba algorithm](https://en.wikipedia.org/wiki/Karatsuba_algorithm#:~:text=The%20Karatsuba%20algorithm%20was%20the,faster%2C%20for%20sufficiently%20large%20n.), one of the most popular multiplication algorithms in computer science.
 
In this blog I will try my best to give a clear and concise explanation of this unpopular algorithm and explain its implementation in C++.
 
More details about Vedic maths can be found [here](https://github.com/KVBharatBhushan/Vedic-Maths)
 
# Algorithm
There is a sequence of patterns to follow when carrying out single digit products. The sequence itself depends on the number of digits in the numbers being multiplied.
 
## Steps
1. For each pattern, compute the sum of all the required single digit products.
2. Add carry (if any) to this sum.
- The last digit of this result is concatenated to the left of our final answer.
- The remaining digits of our sum is our new carry.
- Repeat until all patterns have been exhausted.
 
## Pattern for 2-digit multiplication
![](https://github.com/creme332/big-integer-vedic-multiplication-algorithm/blob/main/Media%20Files/2x2+pattern.gif?raw=true)
 
> The dots represent digits and the lines represent the product of 2 digits.
 
Example :
 
> Multiply 29 and 12
 
![](https://github.com/creme332/big-integer-vedic-multiplication-algorithm/blob/main/Media%20Files/Example+1.gif?raw=true)
 
Step 1 : Multiply the digits in the right-most column to obtain 18.
 
Step 1.1 : Write down only unit digit (8 in this case) and carry over the digit in the tens place (1 in this case).
 
Step 2 : There are two single-digit multiplications to carry out. Sum these products and add the carry from the previous step.
 
Repeat step 1.1
 
## Pattern for 3-digit multiplication
![](https://github.com/creme332/big-integer-vedic-multiplication-algorithm/blob/main/Media%20Files/3x3+pattern.gif?raw=true)
 
## Pattern for 4-digit multiplication
![](https://github.com/creme332/big-integer-vedic-multiplication-algorithm/blob/main/Media%20Files/4x4+pattern.gif?raw=true)
 
## Things to note
- Make use of symmetry to remember the sequence of patterns. Also notice that the last n/2 patterns are simply a reflection in the vertical axis of the first n/2 patterns.
 
- When the 2 numbers being multiplied have different lengths, simply prepend zeros to the smaller number to make it the same length as the larger number. For example, the Criss-Cross multiplication of `512323` and `32` is the same as the Criss-Cross multiplication of `512323` and `000032`.
 
- One of the advantages of the Criss-Cross algorithm is that the risk of integer overflow is small as it carries out the sum of single-digit products.
 
 
# Proof
Even though I have not found a formal proof of the Criss-Cross algorithm, we can get some insights into why it works by comparing it side-by-side with the grade-school algorithm .  
 
Immediately we can notice some similarities :
![image](https://user-images.githubusercontent.com/65414576/155765960-2ec47174-1825-4c9d-8fa9-94a6a6086361.png)
# Code
 
```cpp
    ll i = max, j = min;
 
    for (ll k = 0; k < lines; k++) {
        sum += (a[i] - '0') * (b[j] - '0');
        i--; j++;
    }
```
```min``` and ```max``` keep track of the region within which the cross-multiplication will take place.
 
Example :
 
![](https://github.com/creme332/VedicMultiplicationAlgorithm/blob/a2b8ccf5951fdeb7a31f31aa4754585d8ac21d32/Media%20Files/3x3+min+max%5B2975%5D.gif)
 
![image](https://user-images.githubusercontent.com/65414576/155732674-d9b96441-29d1-42d6-99b4-a4a211b23a46.png)
 
`i` is the index used to iterate over `a` within the region `[min, max]`.
 
`j` is the index used to iterate over `b` within the region `[min, max]`.
 
## Case 1 : Both `a` and  `b` have `n` digits
This is the simplest case. The total number of steps required is `2n-1`. (There are `n` patterns +  `n` reflected patterns. However, the n-th pattern is counted twice so we minus 1.)
 
The number of 1-digit multiplication (or the number of lines drawn) at each step can be found as follows :
```cpp
        if (currentstep <= n) {lines = currentstep;}
        else {lines = n - (currentstep - n);} // or 2*n - currentstep
```
 
| Step number | Number of single digit product required |
| :---        |    :----:   |
| 1      | 1       |
| 2   | 2        |
| 3   | 3        |
| 4   | 4        |
| ...   | ...        |
| n   | n        |
| n+1  | n-1        |
| n+2   | n-2        |
| n+3   | n-3        |
| ...   | ...        |
| 2n-1   | 1        |
 
At each step, we will compute the sum of all the 1-digit multiplications required. From this sum we will obtain the carry for the next step and a digit of our answer.
### Time complexity ###
The total number of single digit products is $n^2 + n - 1$.  In comparison, the total number of single digit products for the Karatsuba algorithm is $n^{\log_2 3}.$
 
![image](https://user-images.githubusercontent.com/65414576/155828159-ae742681-dace-43b3-b0f9-542745d9b108.png)
 
In theory, as the number of digits in the numbers being multiplied tends to infinity, the Karatsuba algorithm will perform better. However, for relatively small numbers (having less than 10,000 digits), the Karatsuba algorithm performs worse.
 
### The pseudocode for Case 1 ###
```
Initialise the total number of steps
Initialise min and max to n-1
 
For each step
        Determine the number of 1-digit multiplication to be carried out
        Initialise sum to 0
        When the step number becomes > n (or when min becomes negative), set min to 0 and decrement max.
       
        For each 1-digit multiplication
                Increment sum
                Modify counters to move to next 1-digit multiplication
       
        Add previous carry to sum
        Update carry and answer
        Decrement min
 
If carry is non-zero, concatenate it to the left of the answer.
Return answer
 
```
 
## Case 2 : `b` has fewer digits than `a` ##
This case could be eliminated if we simply make both `a` and `b` the same length initially by adding leading zeros to `b`. However, this approach is time-consuming because there will be unnecessary and will introduce leading zeros in our final answer which must be removed.
 
To bypass this problem, we simply reduce the total number of steps and the number of single digit products at each step to eliminate cases where the 1-digit multiplication involves a leading zero.
 
The total number of steps is now found using :
```cpp
    const ll asize = static_cast<ll>(a.size());
    const ll bsize = static_cast<ll>(b.size());
    ll totalsteps = asize + bsize - 1;
```
 
For each step, we first find the expected number of 1-digit multiplication if `a` and `b` were the same length :
```cpp
        if (step <= asize) {
             lines = step;
        }
        else {
            lines= asize - (step- asize); // do not simplify as 2*asize might overflow
        }
```
 
When all the digits of `b` have been traversed, `min` becomes negative. Previously when `a` and `b` were the same length, we exited when `min` was negative. However, when they differ in length, we cannot exit. Now, each time `min` reaches the start of `b`, we decrement `max` and keep `min` at index 0 of `b`.
```cpp
        if (min < 0) {
            min = 0;
            max--;
        }
```
Then we reduce the number of 1-digit multiplication as follows :
 
```cpp
        if (min < 0) {
            min = 0;
            max--;
            if (step < asize) {
                lines -= step - bsize;
            }
            else {
                lines -= asize - bsize;
            }
        }
```
![](https://github.com/creme332/VedicMultiplicationAlgorithm/blob/693d7c3bdc8f90d6fb8dfaf60001f69f688ff516/Media%20Files/5x3+min+max.gif)
 
The rest of the code is the same as that in Case 1.
 
# Efficiency #
Time complexity : $\mathbb O(n^2)$
 
Worst case scenario : The 2 numbers have the same number of digits.
 
Space complexity : $\mathbb O(n)$
 
# Testing
 
The code used for comparing  the Criss-Cross algorithm and the Karatsuba algorithm can be found [here](https://github.com/creme332/big-integer-vedic-multiplication-algorithm/blob/main/Testing/tester.cpp)
 
| Number of digits in each number |Number of test cases | Avg time for vedic() | Avg time of karatsuba() | % difference |
| :---             |:----:                 |:----:                |:----:                                   |:----:        |
| 100              | 1000                  | 6033                  | 343458                                  |        98.2  |
| 500              | 100                   |  2263                 | 131762                                |     98.2           |
| 1000             | 200                   |  172990               | 5794911                                  | 97.0            |
 
> The unit of time used is microseconds.
 
# Why use the Criss-Cross algorithm
 
- Much simpler to implement than the Karatsuba algorithm.
- Can be used with pen and paper.

